module scd30
author Markus
version 1 0 
description ''
variables temperature humidity co2 

	spec 'r' 'perform' 'SCD30 send _ read _' 'auto auto' '10' 10
	spec 'r' 'to float' 'to decimal _ _ _ _' 'auto auto auto auto' 10 '10' '10' '10'
	spec ' ' 'SCD30 Read Measurement' 'SCD30 read measurement'
	spec ' ' 'SCD30 Read Loop' 'SCD30 read loop'
	spec 'r' 'SCD30 isReady?' 'SCD30 isReady?'
	spec 'r' 'SGC30 generate CRC' 'generate CRC _' 'auto' 1
	spec 'r' 'SCD30 Firmware' 'SCD30 firmware'
	spec 'r' 'SCD30 Check CRC' 'SCD30 check CRC _' 'auto' '10'
	spec 'r' 'SCD30 Get Automatic Self-Calibration Status' 'SCD30 is calibrating?'
	spec 'r' 'SCD30 Read Measurement Interval' 'SCD30 measurement interval'
	spec ' ' 'SCD30 Set Automatic Self-Calibration Status' 'SCD30 start calibrating'
	spec ' ' 'SCD30 Set Measurement Interval' 'SCD30 measure each _ second' 'auto' '10'
	spec ' ' 'SCD30 Stop Continous Measurement' 'SCD30 stop measuring'
	spec ' ' 'SCD30 Stop Self-Calibrating' 'SCD30 stop calibrating'
	spec ' ' 'SCD30 Trigger Continous Measurement' 'SCD30 start measuring with ambient pressure _' 'auto' ''
	spec ' ' 'SCD30 force recalibration value' 'SCD30 force recalibration value _' 'auto' '10'
	spec 'r' 'SCD30 forced recalibration value' 'SCD30 forced recalibration value'
	spec ' ' 'SCD30 send' 'SCD30 send _ with _' 'auto auto' '' ''
	spec ' ' 'SCD30 set temperture offset' 'SCD30 set temperture offset _' 'auto' '10'
	spec ' ' 'SCD30 soft reset' 'SCD30 soft reset'
	spec ' ' 'SCD30 start measuring' 'SCD30 start measuring'
	spec 'r' 'SCD30 temperature offset' 'SCD30 temperature offset'
	spec ' ' 'SCD30 set altitude compensation' 'SCD30 set altitude compensation _' 'auto' '10'
	spec 'r' 'SCD30 altitude compensation' 'SCD30 altitude compensation'
	spec ' ' 'SCD30 soft reset' 'SCD30 soft reset'

to 'SCD30 Firmware' {
  return (perform (hexToInt 'D100') 2)
}

to 'SCD30 Check CRC' list {
  waitMillis 500
  if (or ((size list) == 0) (((size list) % 3) != 0)) {
    return (booleanConstant false)
  }
  local 'blocks' ((size list) / 3)
  for i blocks {
    local 'toCheck' (((at (((i - 1) * 3) + 1) list) << 8) | (at (((i - 1) * 3) + 2) list))
    local 'result' ('SGC30 generate CRC' toCheck)
    if (result != (at (((i - 1) * 3) + 3) list)) {
      return (booleanConstant false)
    }
  }
  return (booleanConstant true)
}

to 'SCD30 Get Automatic Self-Calibration Status' {
  return ((perform (hexToInt '5306') 2) == 1)
}

to 'SCD30 Read Loop' {
  'SCD30 Trigger Continous Measurement' 1006
  'SCD30 Set Measurement Interval' 2
  forever {
    waitUntil ('SCD30 isReady?')
    'SCD30 Read Measurement'
    sayIt ('[data:join]' 'CO2:' co2 ', Temp:' temperature ', Humidity:' humidity)
  }
}

to 'SCD30 Read Measurement' {
  comment 'When new measurement data is available it can be read out with this command. 
Note that the read header should be send with a delay of > 3ms following the write sequence.
Make sure that the measurement is completed by reading the data ready status bit before read out.'
  local 'all' (newList 18)
  local 'command' (hexToInt '0300')
  local 'cmd' ('[data:makeList]' (command >> 8) (command & (hexToInt 'FF')))
  '[sensors:i2cWrite]' (hexToInt '61') cmd
  waitMillis 3
  '[sensors:i2cRead]' (hexToInt '61') all
  if ('SCD30 Check CRC' all) {
    local 'temp' 0
    co2 = ('to float' (at 1 all) (at 2 all) (at 4 all) (at 5 all))
    temperature = ('to float' (at 7 all) (at 8 all) (at 10 all) (at 11 all))
    humidity = ('to float' (at 13 all) (at 14 all) (at 16 all) (at 17 all))
  }
}

to 'SCD30 Read Measurement Interval' {
  return (perform (hexToInt '4600') 2)
}

to 'SCD30 Set Automatic Self-Calibration Status' {
  'SCD30 send' (hexToInt '5306') 1
}

to 'SCD30 Set Measurement Interval' second {
  'SCD30 send' (hexToInt '4600') second
}

to 'SCD30 Stop Continous Measurement' {
  'SCD30 send' (hexToInt '0104') ''
}

to 'SCD30 Stop Self-Calibrating' {
  'SCD30 send' (hexToInt '5306') 0
}

to 'SCD30 Trigger Continous Measurement' mbar {
  'SCD30 send' (hexToInt '0010') mbar
}

to 'SCD30 force recalibration value' ppm {
  'SCD30 send' (hexToInt '5204') ppm
}

to 'SCD30 forced recalibration value' {
  return (perform (hexToInt '5204') 2)
}

to 'SCD30 set altitude compensation' 'current altitude in meter' {
  comment 'Setting altitude is disregarded when an ambient pressure is given to the sensor
via "SCD30 start measuring with ambient pressure"'
  'SCD30 send' (hexToInt '5102') (v 'current altitude in meter')
}

to 'SCD30 altitude compensation' {
  return (perform (hexToInt '5102') 2)
}

to 'SCD30 isReady?' {
  return ((perform (hexToInt '0202') 2) == 1)
}

to 'SCD30 send' command parameter {
  local 'cmdList' ('[data:makeList]' (command >> 8) (command & (hexToInt 'FF')))
  if (parameter != '') {
    '[data:addLast]' (parameter >> 8) cmdList
    '[data:addLast]' (parameter & (hexToInt 'FF')) cmdList
    '[data:addLast]' ('SGC30 generate CRC' parameter) cmdList
  }
  '[sensors:i2cWrite]' (hexToInt '61') cmdList
}

to 'SCD30 set temperture offset' tick {
  comment 'The on-board RH/T sensor is influenced by thermal self-heating 
of SCD30 and other electrical components. 
Design-in alters the thermal properties of SCD30 such that temperature 
and humidity offsets may occur when operating the sensor in end-customer devices. 
Compensation of those effects is achievable by writing the temperature offset found 
in continuous operation of the device into the sensor.
Temperature offset value is saved in non-volatile memory.
 The last set value will be used for temperature offset compensation after repowering.

Format: uint16 Temperature offset, unit [°C x 100], i.e. one tick corresponds to 0.01°C'
  'SCD30 send' (hexToInt '5403') tick
}

to 'SCD30 start measuring' {
  comment 'argument = 0 deactivates pressure compensation.'
  'SCD30 Trigger Continous Measurement' 0
}

to 'SCD30 temperature offset' {
  return (perform (hexToInt '5403') 2)
}

to 'SGC30 generate CRC' value {
  local 'buf' ('[data:makeList]' (value >> 8) (value & 255))
  local 'crc' (hexToInt 'FF')
  for i (size buf) {
    crc = (crc ^ (at i buf))
    for i 8 {
      if ((crc & (hexToInt '80')) != 0) {
        crc = ((crc << 1) ^ (hexToInt '31'))
      } else {
        crc = (crc << 1)
      }
    }
  }
  return (crc & 255)
}

to perform command size {
  'SCD30 send' command ''
  waitMillis 3
  local 'response' (newList size)
  '[sensors:i2cRead]' (hexToInt '61') response
  local 'singleResponse' (((at 1 response) << 8) | (at 2 response))
  return singleResponse
}

to 'to float' byte1 byte2 byte3 byte4 {
  comment 'Only yields the floor of the decimal at the moment, i.e. no values after the "."'
  local 'exponent' 0
  local 'significand' 0
  local 'byte2_mod' 0
  local 'floor' 0
  exponent = (((byte1 << 1) | (byte2 >> 7)) - 127)
  byte2_mod = ((1 << 7) | byte2)
  significand = ((byte2_mod << 16) | ((byte3 << 8) | byte4))
  floor = (significand >> (23 - exponent))
  if ((byte1 >> 7) != 0) {
    floor = (0 - floor)
  }
  return floor
}

to 'SCD30 soft reset' {
  'SCD30 send' (hexToInt '3D04') ''
}
